{"componentChunkName":"component---src-templates-post-jsx","path":"/blog/mmc-design-decisions/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://github.com/milselarch/--C\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/milselarch/--C</a><br>\n(A WIP as of Oct 2025)</p>\n<p>So my goal with this project is to create a compiler from a source programming language\nto a 1D cellular automata. The primary reason for this is that I think it's possible\nto develop tools to analyze the halt-ability of some classes of programs\nwhen expressed in this form. But I also have personal reasons to want to do this:</p>\n<ol>\n<li>\n<p>to be entirely honestly I've always\nthought that writing a compiler sounds cool and wanted an excuse to\nget into an endeavor as massive as this one</p>\n</li>\n<li>\n<p>I did take a compilers course back in uni, but it always felt incomplete\nin the sense that although we had lessons on the different stages of a\ncompiler as well as a few labs on lexing and parsing,\nwe never actually got around to make a full-fledged compiler.</p>\n<p>Given how stretched thin I was with job search and final year project woes\nthis was objectively a good thing, but now that I have the free time, this\nis something I definitely want to get back into.</p>\n</li>\n</ol>\n<h2>On the Choice of Programming Language</h2>\n<p>So the source programming language could <em>theoretically</em> be anything, but\nthere a couple of requirements I have in mind in practice:</p>\n<ol>\n<li>\n<p>Its gotta be a small programming language<br>\nlanguages like lua and C are relatively small and self-contained, so\nit's possible to make write a compiler / interpreter as a one-man show kinda deal.\nC++ / Rust on the other hand is pretty impractical tackle solo.</p>\n</li>\n<li>\n<p>Its gotta be performant<br>\nThe performance overhead of executing a program after compiling it\ninto a cellular automata is going to be massive no matter what -\nbut a language that:</p>\n<ul>\n<li>is designed to be compiled down to hardware instructions\n(as opposed to being converted to bytecode and executed on a VM\nwith all the associated overheads that that entails)</li>\n<li>has static as opposed to dynamic typing\n(so we don't waste time doing type inference at runtime)\n<br/>\nwould be ideal. Languages like Python and JavaScript and lua\ndon't fit these criteria, while C / C++ / Rust\n(zero-cost abstractions as they like to say) does</li>\n</ul>\n</li>\n</ol>\n<p>I've given the punchline away in the title, but yes, the language\nI've chosen is C - its small and would lend itself well to being translated\ninto cellular automata instructions without too much unnecessary simulation overhead.</p>\n<p>I'm going through Nora Sanders' <a href=\"https://nostarch.com/writing-c-compiler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Let's Build a C Compiler</a>\nbook to incrementally build up the compiler along the well-trodden path\nof source code -> x86 assembly instructions, but will</p>","frontmatter":{"title":"--C","description":"Design goals and plans for my C-to-CA compiler","date":"2025-10-13T00:00:00.000Z","slug":"/blog/mmc-design-decisions/","tags":["Compilers","CellularAutomata"]}}},"pageContext":{}},"staticQueryHashes":["2031412112","2709483142","3539500889","3825832676"],"slicesMap":{}}